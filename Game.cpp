#include "Game.h"
#include"StateMainMenu.h"
#include"StatePlay.h"


GameState * playState;
GameState * mainMenuState;
GameState * currentState;

void setState(GameState * newState);
GameState *getState(void);
GameState *getPlayState(void);
GameState *getMainMenuState(void);


/////////////////////////////////////////////////////////////////////////////


//context.setState(context.getPlayState());


/////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////////
//void Game::setState(gameState* newState)
//{
//	if (newState != currentState)
//	{
//		currentState->exit();  //perform Exit actions on previous state
//		currentState = newState;
//		currentState->enter(); //perform Enter actions on new state
//	}
//}

/////////////////////////////////////////////////////////////////////////////////////////
void Game::init()
{
	window = setupRC(glContext); // Create window and render context
	//	glInit(); // initialise the OpenGL and game variables
	playerLabel = createString("Player");
	playerWidth = width; playerHeight = height;
	targetLabel = createString("Target");
	targetWidth = width; targetHeight = height;

	Player.textToTexture("Player");
	Target.textToTexture("Target");
}



Game::Game()
{
	xpos = 0.0f;
	ypos = 0.0f;
	xsize = 0.15f;
	ysize = 0.15f;

	targetXPos = 0.0f;
	targetYPos = 0.0f;
	targetXSize = 0.1f;
	targetYSize = 0.1f;

	score = 0;
}
// We should be able to detect when errors occur with SDL if there are 
// unrecoverable errors, then we need to print an error message and quit the program
void Game::exitFatalError(char *message)
{
	std::cout << message << " " << SDL_GetError();
	SDL_Quit();
	exit(1);
}


// Set up rendering context
// Sets values for, and creates an OpenGL context for use with SDL
SDL_Window * Game::setupRC(SDL_GLContext &context)
{
	SDL_Window *window;
	if (SDL_Init(SDL_INIT_VIDEO) < 0) // Initialize video
		exitFatalError("Unable to initialize SDL");

	// Request an OpenGL 2.1 context.
	// If you request a context not supported by your drivers, no OpenGL context will be created
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 1);

	SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);  // double buffering on
	SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8); // 8 bit alpha buffering

	// Optional: Turn on x4 multisampling anti-aliasing (MSAA)
	SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1);
	SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, 4);

	// Create 800x600 window
	window = SDL_CreateWindow("SDL OpenGL Demo for GED",
		SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
		800, 600, SDL_WINDOW_OPENGL | SDL_WINDOW_SHOWN);
	if (!window) // Check window was created OK
		exitFatalError("Unable to create window");

	context = SDL_GL_CreateContext(window); // Create opengl context and attach to window
	SDL_GL_SetSwapInterval(1); // set swap buffers to sync with monitor's vertical refresh rate

	// set up TrueType / SDL_ttf
	if (TTF_Init() == -1)
		exitFatalError("TTF failed to initialise.");

	textFont = TTF_OpenFont("MavenPro-Regular.ttf", 24);
	if (textFont == NULL)
		exitFatalError("Failed to open font.");

	return window;
}


// Initialise OpenGL values and game related values and variables
void Game::glInit(void)
{
	glClearColor(0.0, 0.0, 0.0, 0.0); // set background colour

	std::srand(std::time(NULL));
	targetXPos = (float)rand() / RAND_MAX - 0.75f;
	targetYPos = (float)rand() / RAND_MAX - 0.75f;
	lastTime = clock();
}


// OpenGL works best with images where sides are powers of two - odd issues
// can occur with some drivers/hardware when image dimensions are not power of two 
// This function will return the smallest power of two larger than or equal to the
// input parameter
int Game::powerOfTwo(int x) {
	int size = 1;
	while (size < x)
		size *= 2; // Times two will usually be optimised to 'shift right' operation

	return size;
}


GLuint Game::createString(const char *str)
{
	// First, create a SDL surface with the text
	SDL_Surface *stringImage = NULL;
	SDL_Color colour = { 255, 255, 0 };

	// A few steps here: the image generated by SDL's text rendering can
	// be of any size, but OpenGL works best with images that are in regular power of two dimensions
	// This code uses SDL to create a texture for a label, then copy that to another texture
	// of appropriate dimensions for use in OpenGL
	stringImage = TTF_RenderText_Blended(textFont, str, colour);

	if (stringImage == NULL)
		exitFatalError("String surface not created.");

	width = powerOfTwo(stringImage->w);
	height = powerOfTwo(stringImage->h);

	SDL_Surface *glImage = NULL;
	glImage = SDL_CreateRGBSurface(SDL_SWSURFACE, width, height, 32,
		0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000);

	SDL_BlitSurface(stringImage, NULL, glImage, NULL);

	// Copy the SDL surface to an OpenGL texture
	GLuint texture;
	glGenTextures(1, &texture);
	glBindTexture(GL_TEXTURE_2D, texture);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0,
		GL_RGBA, GL_UNSIGNED_BYTE, glImage->pixels);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
	// SDL surfaces no longer required
	SDL_FreeSurface(stringImage);
	SDL_FreeSurface(glImage);

	return texture;
}




// This function assumes that strings are dynamic:
// creating and deleting textures for the string
// Strings that remain throughout the game should only be generated once
// or should be generated at compile time and loaded as fixed textures
// Generating textures during init at run time can make it easier to change
// text, while using artist generated textures can allow for a much more
// professional quality finish on the graphics
void Game::displayString(float x, float y, GLuint textureID, int w, int h)
{

	// Draw texture here
	glEnable(GL_TEXTURE_2D);
	glBindTexture(GL_TEXTURE_2D, textureID);
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	glBegin(GL_QUADS);
	glTexCoord2d(0, 1); // Texture has origin at top not bottom
	glVertex3f(x, y, 0.0); // first corner
	glTexCoord2d(1, 1);
	glVertex3f(x + 0.002f*w, y, 0.0); // second corner
	glTexCoord2d(1, 0);
	glVertex3f(x + 0.002f*w, y + 0.002f*h, 0.0); // third corner
	glTexCoord2d(0, 0);
	glVertex3f(x, y + 0.002f*h, 0.0); // fourth corner
	glEnd();

	// As this texture is not being kept, delete it here
	// For labels that do not change, it would be better to not have to recreate them every
	// frame
	glDisable(GL_TEXTURE_2D);
}

void Game::deleteString(GLuint textureID)
{
	glDeleteTextures(1, &textureID);
}

// The main rendering function
// In principle, this function should never perform updates to the game
// ONLY render the current state. Reacting to events should be taken care
// of in a seperate update function
void Game::draw()
{
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear window

	// draw player
	glColor3f(1.0, 1.0, 1.0);
	glBegin(GL_POLYGON);
	glVertex3f(xpos, ypos, 0.0); // first corner
	glVertex3f(xpos + xsize, ypos, 0.0); // second corner
	glVertex3f(xpos + xsize, ypos + ysize, 0.0); // third corner
	glVertex3f(xpos, ypos + ysize, 0.0); // fourth corner
	glEnd();
	Player.drawLabel(xpos +6 +  (xsize / 2.0f), ypos + ysize);
	displayString(xpos+(xsize/2.0f), ypos+ysize, playerLabel, playerWidth, playerHeight);// this line draws text on the screen(can use either one)

	// draw target
	glColor3f(1.0, 0.0, 0.0);
	glBegin(GL_POLYGON);
	glVertex3f(targetXPos, targetYPos, 0.0); // first corner
	glVertex3f(targetXPos + targetXSize, targetYPos, 0.0); // second corner
	glVertex3f(targetXPos + targetXSize, targetYPos + targetYSize, 0.0); // third corner
	glVertex3f(targetXPos, targetYPos + targetYSize, 0.0); // fourth corner
	glEnd();
	Target.drawLabel(targetXPos, targetYPos + targetYSize);  // these two lines draw text on the screen(can use either one)
	//displayString(targetXPos+(targetXSize/2.0f), targetYPos+targetYSize, targetLabel, targetWidth, targetHeight);

	if ((targetXPos >= xpos) && (targetXPos + targetXSize <= xpos + xsize)	// cursor surrounds target in x
		&& (targetYPos >= ypos) && (targetYPos + targetYSize <= ypos + ysize)) // cursor surrounds target in y
	{
		score += 100; // congrats, player has scored!
		// randomize the new target position
		targetXPos = (float)rand() / RAND_MAX - 0.75f;
		targetYPos = (float)rand() / RAND_MAX - 0.75f;
	}

	// Calculate ms/frame
	// Some OpenGL drivers will limit the frames to 60fps (16.66 ms/frame)
	// If so, expect to see the time to rapidly switch between 16 and 17...
	glColor3f(1.0, 1.0, 1.0);
	currentTime = clock();
	// On some systems, CLOCKS_PER_SECOND is 1000, which makes the arithmetic below redundant
	// - but this is not necessarily the case on all systems
	float milliSecondsPerFrame = ((currentTime - lastTime) / (float)CLOCKS_PER_SEC * 1000);

	// Print out the score and frame time information
	std::stringstream strStream;
	strStream << "Score:" << score;
	strStream << "          ms/frame: " << milliSecondsPerFrame;
	GLuint timerLabel;
	timerLabel = createString(strStream.str().c_str());
	displayString(-0.9, 0.9, timerLabel, width, height);
	deleteString(timerLabel);
	lastTime = clock();

	SDL_GL_SwapWindow(window); // swap buffers
}


// The event handling function
// In principle, this function should never perform updates to the game
// ONLY detect what events have taken place. Reacting to the events should 
// be taken care of in a seperate update function
// This would allow e.g. diagonal movement when two keys are pressed together
// (which is not possible with this implementation)
void Game::handleSDLEvent(SDL_Event const &sdlEvent)
{
	if (sdlEvent.type == SDL_KEYDOWN)
	{
		//std::cout << "Scancode: " << sdlEvent.key.keysym.scancode  ;
		//std::cout <<  ", Name: " << SDL_GetKeyName( sdlEvent.key.keysym.sym ) << std::endl;
		switch (sdlEvent.key.keysym.sym)
		{
		case SDLK_UP:
		case 'w': case 'W':
			ypos += 0.05f;
			break;
		case SDLK_DOWN:
		case 's': case 'S':
			ypos -= 0.05f;
			break;
		case SDLK_LEFT:
		case 'a': case 'A':
			xpos -= 0.05f;
			break;
		case SDLK_RIGHT:
		case 'd': case 'D':
			xpos += 0.05f;
			break;
		default:
			break;
		}
	}
}


void Game::run(void)
{
	bool running = true; // set running to true
	SDL_Event sdlEvent; // variable to detect SDL events

	std::cout << "Progress: About to enter main loop" << std::endl;

	// unlike GLUT, SDL requires you to write your own event loop
	// This puts much more power in the hands of the programmer
	// This simple loop only responds to the window being closed.
	while (running)	// the event loop
	{
		while (SDL_PollEvent(&sdlEvent))
		{
			if (sdlEvent.type == SDL_QUIT)
				running = false;
			else
				handleSDLEvent(sdlEvent);

		}
		//update(); // this is the place to put a call to the game update function
		draw(); // call the draw function




		////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/*while (SDL_PollEvent(&sdlEvent))
		{
		if (sdlEvent.type == SDL_QUIT)
		running = false;
		else
		currentState->handleSDLEvent(sdlEvent, *this);
		}
		currentState->draw(window);*/
		/////////////////////////////////////////////////////////////////////////
	}


	deleteString(playerLabel);
	deleteString(targetLabel);

	TTF_CloseFont(textFont);
	SDL_DestroyWindow(window);
	SDL_Quit();
	//    return 0;

}